<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>‰øÑÁΩóÊñØÊñπÂùó</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 10px;
    touch-action: manipulation;
    overflow: hidden;
}

.game-container {
    position: relative;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
    padding: 20px;
    max-width: 500px;
    width: 100%;
    backdrop-filter: blur(10px);
    overflow: hidden;
}

/* Á≤íÂ≠êËÉåÊôØ */
.particles {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
}

.particles::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(120, 219, 255, 0.3) 0%, transparent 50%);
    animation: particleFloat 6s ease-in-out infinite;
}

@keyframes particleFloat {
    0%, 100% { transform: translateY(0px) rotate(0deg); }
    50% { transform: translateY(-10px) rotate(180deg); }
}

.header {
    position: relative;
    z-index: 1;
    text-align: center;
    margin-bottom: 20px;
}

.header h1 {
    color: #333;
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 15px;
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    animation: titleGlow 2s ease-in-out infinite alternate;
}

@keyframes titleGlow {
    from { text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
    to { text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1), 0 0 20px rgba(102, 126, 234, 0.3); }
}

.score-board {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
}

.score-item {
    background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    color: white;
    padding: 8px 12px;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
    transition: all 0.3s ease;
}

.score-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
}

.score-item span:first-child {
    display: block;
    font-size: 10px;
    opacity: 0.8;
}

.score-value {
    display: block;
    font-size: 16px;
    font-weight: bold;
    margin-top: 2px;
    transition: all 0.3s ease;
}

.combo.active {
    animation: comboGlow 0.5s ease-in-out;
    color: #ffeb3b;
    text-shadow: 0 0 10px #ffeb3b;
}

@keyframes comboGlow {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.game-area {
    position: relative;
    z-index: 1;
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    align-items: flex-start;
}

.side-panel {
    display: flex;
    flex-direction: column;
    gap: 15px;
    flex-shrink: 0;
}

.next-piece {
    background: rgba(248, 249, 250, 0.9);
    border-radius: 10px;
    padding: 10px;
    text-align: center;
}

.next-piece h3 {
    color: #333;
    font-size: 12px;
    margin-bottom: 8px;
}

.next-piece canvas {
    background: #f8f9fa;
    border: 2px solid #e9ecef;
    border-radius: 8px;
    display: block;
    margin: 0 auto;
}

.game-board {
    position: relative;
    flex: 1;
}

.game-board canvas {
    background: #1a1a1a;
    border: 3px solid #333;
    border-radius: 10px;
    width: 100%;
    height: auto;
    max-width: 300px;
    max-height: 600px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
    display: block;
}

/* Ê∂àË°åÂä®ÁîªÊïàÊûú */
.clear-effects {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
}

.clear-effect {
    position: absolute;
    left: 0;
    width: 100%;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.clear-effect.single {
    animation: clearSingle 1s ease-out forwards;
}

.clear-effect.double {
    animation: clearDouble 1.2s ease-out forwards;
}

.clear-effect.triple {
    animation: clearTriple 1.5s ease-out forwards;
}

.clear-effect.tetris {
    animation: clearTetris 2s ease-out forwards;
}

.clear-text {
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 0 10px currentColor;
    z-index: 2;
}

.clear-particles {
    position: absolute;
    width: 100%;
    height: 100%;
}

.particle {
    position: absolute;
    width: 4px;
    height: 4px;
    background: radial-gradient(circle, #fff 0%, transparent 70%);
    border-radius: 50%;
    animation: particleExplode 1s ease-out forwards;
}

.particle:nth-child(odd) {
    animation-delay: 0.1s;
}

.particle:nth-child(even) {
    animation-delay: 0.2s;
}

@keyframes clearSingle {
    0% {
        opacity: 0;
        transform: scale(0.5);
    }
    50% {
        opacity: 1;
        transform: scale(1.2);
    }
    100% {
        opacity: 0;
        transform: scale(1) translateY(-20px);
    }
}

@keyframes clearDouble {
    0% {
        opacity: 0;
        transform: scale(0.5) rotate(-10deg);
    }
    50% {
        opacity: 1;
        transform: scale(1.3) rotate(5deg);
    }
    100% {
        opacity: 0;
        transform: scale(1) rotate(0deg) translateY(-30px);
    }
}

@keyframes clearTriple {
    0% {
        opacity: 0;
        transform: scale(0.3) rotate(-20deg);
    }
    30% {
        opacity: 1;
        transform: scale(1.5) rotate(10deg);
    }
    70% {
        opacity: 1;
        transform: scale(1.2) rotate(-5deg);
    }
    100% {
        opacity: 0;
        transform: scale(1) rotate(0deg) translateY(-40px);
    }
}

@keyframes clearTetris {
    0% {
        opacity: 0;
        transform: scale(0.2) rotate(-30deg);
    }
    20% {
        opacity: 1;
        transform: scale(1.8) rotate(15deg);
    }
    40% {
        opacity: 1;
        transform: scale(1.5) rotate(-10deg);
    }
    60% {
        opacity: 1;
        transform: scale(1.3) rotate(5deg);
    }
    100% {
        opacity: 0;
        transform: scale(1) rotate(0deg) translateY(-50px);
    }
}

@keyframes particleExplode {
    0% {
        opacity: 1;
        transform: scale(0) translate(0, 0);
    }
    50% {
        opacity: 1;
        transform: scale(1) translate(var(--random-x, 0), var(--random-y, 0));
    }
    100% {
        opacity: 0;
        transform: scale(0) translate(var(--random-x, 0), var(--random-y, 0));
    }
}

/* ËøûÂáªÊòæÁ§∫ */
.combo-display {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 24px;
    font-weight: bold;
    color: #ffeb3b;
    text-shadow: 0 0 20px #ffeb3b;
    z-index: 15;
    pointer-events: none;
}

.combo-display.combo-2 {
    animation: comboShow 1s ease-out forwards;
    color: #4caf50;
    text-shadow: 0 0 20px #4caf50;
}

.combo-display.combo-3 {
    animation: comboShow 1.2s ease-out forwards;
    color: #ff9800;
    text-shadow: 0 0 20px #ff9800;
}

.combo-display.combo-4 {
    animation: comboShow 1.5s ease-out forwards;
    color: #f44336;
    text-shadow: 0 0 20px #f44336;
}

@keyframes comboShow {
    0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.5);
    }
    50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.3);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(1) translateY(-30px);
    }
}

.game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.95);
    color: white;
    padding: 30px;
    border-radius: 15px;
    text-align: center;
    backdrop-filter: blur(10px);
    z-index: 20;
    animation: gameOverShow 0.5s ease-out;
}

@keyframes gameOverShow {
    from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

.game-over h2 {
    font-size: 24px;
    margin-bottom: 15px;
    color: #ff6b6b;
}

.final-score, .max-combo {
    color: #4facfe;
    font-weight: bold;
}

.restart-btn {
    background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    color: white;
    border: none;
    padding: 12px 24px;
    border-radius: 25px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s;
    box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
    margin-top: 15px;
}

.restart-btn:active {
    transform: scale(0.95);
}

.pause-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 15;
    backdrop-filter: blur(5px);
}

.pause-content {
    text-align: center;
    color: white;
}

.pause-content h2 {
    font-size: 28px;
    margin-bottom: 10px;
}

.controls {
    position: relative;
    z-index: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.control-row {
    display: flex;
    gap: 10px;
    justify-content: center;
}

.control-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
    min-width: 60px;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    position: relative;
    overflow: hidden;
}

.control-btn::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    transition: width 0.3s, height 0.3s;
}

.control-btn:active::before {
    width: 100px;
    height: 100px;
}

.control-btn:active {
    transform: scale(0.95);
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
}

.control-btn.pressing {
    background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
    transform: scale(0.95);
}

.rotate-btn, .pause-btn {
    flex: 1;
}

.move-btn, .down-btn {
    flex: 1;
}

/* iPhoneÈÄÇÈÖç */
@media (max-width: 480px) {
    body {
        padding: 5px;
        overflow-x: hidden;
    }
    
    .game-container {
        padding: 10px;
        margin: 0;
        max-width: 100%;
        width: 100vw;
        max-height: 100vh;
        border-radius: 15px;
    }
    
    .header h1 {
        font-size: 20px;
        margin-bottom: 10px;
    }
    
    .score-board {
        grid-template-columns: repeat(2, 1fr);
        gap: 5px;
        margin-bottom: 15px;
    }
    
    .score-item {
        padding: 5px 8px;
    }
    
    .score-value {
        font-size: 13px;
    }
    
    .game-area {
        flex-direction: column;
        align-items: center;
        gap: 10px;
        margin-bottom: 15px;
    }
    
    .side-panel {
        flex-direction: row;
        width: 100%;
        justify-content: center;
    }
    
    .next-piece {
        padding: 8px;
    }
    
    .next-piece h3 {
        font-size: 11px;
        margin-bottom: 5px;
    }
    
    .next-piece canvas {
        width: 60px;
        height: 60px;
    }
    
    .game-board {
        width: 100%;
        display: flex;
        justify-content: center;
    }
    
    .game-board canvas {
        max-width: calc(100vw - 40px);
        max-height: calc(50vh);
        width: 280px;
        height: 560px;
    }
    
    .controls {
        margin-top: 10px;
    }
    
    .control-btn {
        padding: 10px 14px;
        font-size: 13px;
        margin: 2px;
    }
}

@media (max-width: 375px) {
    .game-container {
        padding: 5px;
    }
    
    .header {
        margin-bottom: 8px;
    }
    
    .score-board {
        margin-bottom: 8px;
    }
    
    .game-area {
        margin-bottom: 8px;
    }
    
    .game-board canvas {
        width: 240px;
        height: 480px;
        max-width: calc(100vw - 20px);
        max-height: calc(45vh);
    }
    
    .control-btn {
        padding: 6px 10px;
        font-size: 11px;
        min-width: 40px;
    }
    
    .header h1 {
        font-size: 16px;
        margin-bottom: 5px;
    }
}

@media (max-width: 320px) {
    .game-container {
        padding: 3px;
    }
    
    .game-board canvas {
        width: 220px;
        height: 440px;
        max-height: calc(40vh);
    }
    
    .control-btn {
        padding: 5px 8px;
        font-size: 10px;
        min-width: 35px;
        margin: 1px;
    }
    
    .header h1 {
        font-size: 14px;
    }
    
    .score-item {
        padding: 3px 5px;
    }
    
    .score-value {
        font-size: 11px;
    }
}

/* Èò≤Ê≠¢ÈÄâ‰∏≠ÊñáÊú¨ */
.control-btn, .game-container {
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* ‰ºòÂåñËß¶Êë∏ÂèçÈ¶à */
@media (hover: hover) {
    .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    
    .control-btn:hover::before {
        width: 50px;
        height: 50px;
    }
}

/* ÈïøÊåâÊïàÊûú */
@keyframes longPressEffect {
    0% { background-position: 0% 50%; }
    100% { background-position: 100% 50%; }
}

.control-btn.long-pressing {
    background: linear-gradient(45deg, #667eea, #764ba2, #667eea, #764ba2);
    background-size: 300% 300%;
    animation: longPressEffect 0.5s ease infinite;
}
    </style>
</head>
<body>
    <div id="app">
        <div class="game-container">
            <!-- Á≤íÂ≠êËÉåÊôØ -->
            <div class="particles" ref="particles"></div>
            
            <div class="header">
                <h1>‰øÑÁΩóÊñØÊñπÂùó</h1>
                <div class="score-board">
                    <div class="score-item">
                        <span>ÂæóÂàÜ</span>
                        <span class="score-value">{{ score }}</span>
                    </div>
                    <div class="score-item">
                        <span>Á≠âÁ∫ß</span>
                        <span class="score-value">{{ level }}</span>
                    </div>
                    <div class="score-item">
                        <span>Ë°åÊï∞</span>
                        <span class="score-value">{{ lines }}</span>
                    </div>
                    <div class="score-item">
                        <span>ËøûÂáª</span>
                        <span class="score-value combo" :class="{active: combo > 1}">{{ combo }}x</span>
                    </div>
                </div>
            </div>
            
            <div class="game-area">
                <div class="side-panel">
                    <div class="next-piece">
                        <h3>‰∏ã‰∏Ä‰∏™</h3>
                        <canvas ref="nextCanvas" width="80" height="80"></canvas>
                    </div>
                </div>
                
                <div class="game-board">
                    <canvas ref="gameCanvas" width="300" height="600" 
                            @touchstart="handleTouchStart" 
                            @touchmove="handleTouchMove" 
                            @touchend="handleTouchEnd"></canvas>
                    
                    <!-- Ê∂àË°åÂä®ÁîªÂ±Ç -->
                    <div class="clear-effects">
                        <div v-for="effect in clearEffects" :key="effect.id" 
                             class="clear-effect" 
                             :class="effect.type"
                             :style="{top: effect.y + 'px'}">
                            <div class="clear-text">{{ effect.text }}</div>
                            <div class="clear-particles">
                                <div v-for="i in effect.particleCount" :key="i" class="particle"></div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- ËøûÂáªÊèêÁ§∫ -->
                    <div v-if="comboText" class="combo-display" :class="comboClass">
                        {{ comboText }}
                    </div>
                    
                    <!-- Ê∏∏ÊàèÁªìÊùü -->
                    <div v-if="gameOver" class="game-over">
                        <h2>üéØ Ê∏∏ÊàèÁªìÊùü</h2>
                        <p>ÊúÄÁªàÂæóÂàÜ: <span class="final-score">{{ score }}</span></p>
                        <p>ÊúÄÈ´òËøûÂáª: <span class="max-combo">{{ maxCombo }}x</span></p>
                        <button @click="restart" class="restart-btn">üîÑ ÈáçÊñ∞ÂºÄÂßã</button>
                    </div>
                    
                    <!-- ÊöÇÂÅú -->
                    <div v-if="paused && !gameOver" class="pause-overlay">
                        <div class="pause-content">
                            <h2>‚è∏Ô∏è Ê∏∏ÊàèÊöÇÂÅú</h2>
                            <p>ÁÇπÂáªÁªßÁª≠ÊåâÈíÆÊÅ¢Â§çÊ∏∏Êàè</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <div class="control-row">
                    <button @touchstart="handleRotateTouch" @touchend="handleTouchEndBtn" @mousedown="startRotate" @mouseup="stopAction" class="control-btn rotate-btn">üîÑ ÊóãËΩ¨</button>
                    <button @click="togglePause" class="control-btn pause-btn">{{ paused ? '‚ñ∂Ô∏è ÁªßÁª≠' : '‚è∏Ô∏è ÊöÇÂÅú' }}</button>
                </div>
                <div class="control-row">
                    <button @touchstart="handleMoveTouch(-1)" @touchend="handleTouchEndBtn" @mousedown="startMove(-1)" @mouseup="stopAction" class="control-btn move-btn">‚¨ÖÔ∏è</button>
                    <button @touchstart="handleMoveTouch(0, 1)" @touchend="handleTouchEndBtn" @mousedown="startMove(0, 1)" @mouseup="stopAction" class="control-btn down-btn">‚¨áÔ∏è</button>
                    <button @touchstart="handleMoveTouch(1)" @touchend="handleTouchEndBtn" @mousedown="startMove(1)" @mouseup="stopAction" class="control-btn move-btn">‚û°Ô∏è</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
const { createApp } = Vue;

const app = createApp({
    data() {
        return {
            // Ê∏∏ÊàèÁä∂ÊÄÅ
            board: [],
            currentPiece: null,
            nextPiece: null,
            score: 0,
            level: 1,
            lines: 0,
            combo: 0,
            maxCombo: 0,
            dropTime: 0,
            dropInterval: 1000,
            lastTime: 0,
            paused: false,
            gameOver: false,
            
            // Ê∏∏ÊàèÈÖçÁΩÆ
            BOARD_WIDTH: 10,
            BOARD_HEIGHT: 20,
            BLOCK_SIZE: 30,
            
            // È¢úËâ≤ÈÖçÁΩÆ
            colors: [
                null,
                '#ff0d72', '#0dc2ff', '#0dff72',
                '#f538ff', '#ff8e0d', '#ffe138', '#3877ff'
            ],
            
            // ÊñπÂùóÂÆö‰πâ
            pieces: {
                'T': [[[0,0,0],[1,1,1],[0,1,0]],[[0,1,0],[1,1,0],[0,1,0]],[[0,1,0],[1,1,1],[0,0,0]],[[0,1,0],[0,1,1],[0,1,0]]],
                'O': [[[1,1],[1,1]]],
                'L': [[[0,0,1],[1,1,1]],[[1,0],[1,0],[1,1]],[[1,1,1],[1,0,0]],[[1,1],[0,1],[0,1]]],
                'J': [[[1,0,0],[1,1,1]],[[1,1],[1,0],[1,0]],[[1,1,1],[0,0,1]],[[0,1],[0,1],[1,1]]],
                'I': [[[0,0,0,0],[1,1,1,1]],[[0,1],[0,1],[0,1],[0,1]]],
                'S': [[[0,1,1],[1,1,0]],[[1,0],[1,1],[0,1]]],
                'Z': [[[1,1,0],[0,1,1]],[[0,1],[1,1],[1,0]]]
            },
            
            // Âä®ÁîªÊïàÊûú
            clearEffects: [],
            comboText: '',
            comboClass: '',
            effectId: 0,
            
            // Èü≥ÊïàÁ≥ªÁªü
            audioContext: null,
            sounds: {},
            
            // ÊéßÂà∂Áõ∏ÂÖ≥
            actionInterval: null,
            actionType: null,
            longPressTimer: null,
            keyPressed: {},
            
            // Ëß¶Êë∏ÊéßÂà∂
            touchStartX: 0,
            touchStartY: 0,
            touchStartTime: 0
        }
    },
    
    computed: {
        pieceTypes() {
            return Object.keys(this.pieces);
        }
    },
    
    mounted() {
        this.initGame();
        this.initAudio();
        this.bindEvents();
        this.gameLoop();
    },
    
    methods: {
        initGame() {
            this.board = Array(this.BOARD_HEIGHT).fill().map(() => Array(this.BOARD_WIDTH).fill(0));
            this.generatePiece();
            this.generateNextPiece();
            this.setupCanvas();
            // Á°Æ‰øùÁîªÂ∏ÉÂàùÂßãÂåñÂêéÁªòÂà∂
            this.$nextTick(() => {
                this.drawNext();
            });
        },
        
        setupCanvas() {
            const canvas = this.$refs.gameCanvas;
            canvas.width = this.BOARD_WIDTH * this.BLOCK_SIZE;
            canvas.height = this.BOARD_HEIGHT * this.BLOCK_SIZE;
        },
        
        generatePiece() {
            const type = this.nextPiece || this.pieceTypes[Math.floor(Math.random() * this.pieceTypes.length)];
            this.currentPiece = {
                type: type,
                shape: this.pieces[type][0],
                x: Math.floor(this.BOARD_WIDTH / 2) - 1,
                y: 0,
                rotation: 0,
                color: this.pieceTypes.indexOf(type) + 1
            };
            
            if (this.collision()) {
                this.endGame();
            }
        },
        
        generateNextPiece() {
            this.nextPiece = this.pieceTypes[Math.floor(Math.random() * this.pieceTypes.length)];
            this.drawNext();
        },
        
        collision() {
            for (let y = 0; y < this.currentPiece.shape.length; y++) {
                for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                    if (this.currentPiece.shape[y][x]) {
                        const boardX = this.currentPiece.x + x;
                        const boardY = this.currentPiece.y + y;
                        
                        if (boardX < 0 || boardX >= this.BOARD_WIDTH ||
                            boardY >= this.BOARD_HEIGHT ||
                            (boardY >= 0 && this.board[boardY][boardX])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        },
        
        placePiece() {
            for (let y = 0; y < this.currentPiece.shape.length; y++) {
                for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                    if (this.currentPiece.shape[y][x]) {
                        const boardY = this.currentPiece.y + y;
                        const boardX = this.currentPiece.x + x;
                        if (boardY >= 0) {
                            this.board[boardY][boardX] = this.currentPiece.color;
                        }
                    }
                }
            }
            
            this.playSound('place');
            this.checkLines();
            this.generatePiece();
            this.generateNextPiece();
        },
        
        checkLines() {
            let linesCleared = 0;
            const clearedRows = [];
            
            for (let y = this.BOARD_HEIGHT - 1; y >= 0; y--) {
                if (this.board[y].every(cell => cell !== 0)) {
                    clearedRows.push(y);
                    this.board.splice(y, 1);
                    this.board.unshift(Array(this.BOARD_WIDTH).fill(0));
                    linesCleared++;
                    y++; // ÈáçÊñ∞Ê£ÄÊü•Âêå‰∏ÄË°å
                }
            }
            
            if (linesCleared > 0) {
                this.lines += linesCleared;
                this.combo++;
                
                // ËÆ°ÁÆóÂæóÂàÜÔºàËøûÂáªÂä†ÊàêÔºâ
                const baseScore = linesCleared * 100 * this.level;
                const comboBonus = this.combo > 1 ? (this.combo - 1) * 50 : 0;
                this.score += baseScore + comboBonus;
                
                this.level = Math.floor(this.lines / 10) + 1;
                this.dropInterval = Math.max(50, 1000 - (this.level - 1) * 50);
                
                // Êõ¥Êñ∞ÊúÄÈ´òËøûÂáª
                if (this.combo > this.maxCombo) {
                    this.maxCombo = this.combo;
                }
                
                // Êí≠ÊîæÊ∂àË°åÈü≥Êïà
                if (linesCleared === 4) {
                    this.playSound('tetris');
                } else {
                    this.playSound('clear');
                }
                
                // ÊòæÁ§∫Ê∂àË°åÂä®Áîª
                this.showClearEffect(linesCleared, clearedRows);
                
                // ÊòæÁ§∫ËøûÂáªÊèêÁ§∫
                if (this.combo > 1) {
                    this.showComboText();
                    this.playSound('combo');
                }
            } else {
                this.combo = 0;
            }
        },
        
        showClearEffect(linesCleared, rows) {
            const effectTypes = ['single', 'double', 'triple', 'tetris'];
            const effectTexts = ['Â•Ω!', 'ÁúüÂ•Ω!', 'Â§™ÂéâÂÆ≥‰∫Ü!', 'ÁúüÁâõÈÄºÂïä!'];
            const particleCounts = [8, 12, 16, 24];
            
            rows.forEach((row, index) => {
                const effect = {
                    id: this.effectId++,
                    type: effectTypes[Math.min(linesCleared - 1, 3)],
                    text: effectTexts[Math.min(linesCleared - 1, 3)],
                    y: row * this.BLOCK_SIZE,
                    particleCount: particleCounts[Math.min(linesCleared - 1, 3)]
                };
                
                this.clearEffects.push(effect);
                
                // ËÆæÁΩÆÁ≤íÂ≠êÈöèÊú∫‰ΩçÁΩÆ
                this.$nextTick(() => {
                    const particles = document.querySelectorAll(`[data-effect-id="${effect.id}"] .particle`);
                    particles.forEach(particle => {
                        const randomX = (Math.random() - 0.5) * 200 + 'px';
                        const randomY = (Math.random() - 0.5) * 100 + 'px';
                        particle.style.setProperty('--random-x', randomX);
                        particle.style.setProperty('--random-y', randomY);
                    });
                });
                
                // Ê∏ÖÁêÜÂä®Áîª
                setTimeout(() => {
                    this.clearEffects = this.clearEffects.filter(e => e.id !== effect.id);
                }, 2000);
            });
        },
        
        showComboText() {
            const comboTexts = ['', '', 'COMBO!', 'GREAT!', 'EXCELLENT!', 'AMAZING!', 'INCREDIBLE!'];
            this.comboText = `${this.combo}x ${comboTexts[Math.min(this.combo, 6)] || 'LEGENDARY!'}`;
            this.comboClass = `combo-${Math.min(this.combo, 4)}`;
            
            setTimeout(() => {
                this.comboText = '';
                this.comboClass = '';
            }, 1500);
        },
        
        move(dx, dy = 0) {
            this.currentPiece.x += dx;
            this.currentPiece.y += dy;
            
            if (this.collision()) {
                this.currentPiece.x -= dx;
                this.currentPiece.y -= dy;
                
                if (dy > 0) {
                    this.placePiece();
                }
                return false;
            }
            return true;
        },
        
        rotate() {
            const originalRotation = this.currentPiece.rotation;
            this.currentPiece.rotation = (this.currentPiece.rotation + 1) % this.pieces[this.currentPiece.type].length;
            this.currentPiece.shape = this.pieces[this.currentPiece.type][this.currentPiece.rotation];
            
            if (this.collision()) {
                // Â∞ùËØï‰ΩçÁßª
                for (let dx of [1, -1, 2, -2]) {
                    this.currentPiece.x += dx;
                    if (!this.collision()) {
                        return;
                    }
                    this.currentPiece.x -= dx;
                }
                
                // ÊÅ¢Â§çÊóãËΩ¨
                this.currentPiece.rotation = originalRotation;
                this.currentPiece.shape = this.pieces[this.currentPiece.type][this.currentPiece.rotation];
            }
        },
        
        drop() {
            while (this.move(0, 1)) {}
        },
        
        draw() {
            const canvas = this.$refs.gameCanvas;
            const ctx = canvas.getContext('2d');
            
            // Ê∏ÖÁ©∫ÁîªÂ∏É
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ÁªòÂà∂ÁΩëÊ†º
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let x = 0; x <= this.BOARD_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * this.BLOCK_SIZE, 0);
                ctx.lineTo(x * this.BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= this.BOARD_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * this.BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * this.BLOCK_SIZE);
                ctx.stroke();
            }
            
            // ÁªòÂà∂Â∑≤ÊîæÁΩÆÁöÑÊñπÂùó
            for (let y = 0; y < this.BOARD_HEIGHT; y++) {
                for (let x = 0; x < this.BOARD_WIDTH; x++) {
                    if (this.board[y][x]) {
                        this.drawBlock(ctx, x, y, this.colors[this.board[y][x]]);
                    }
                }
            }
            
            // ÁªòÂà∂ÂΩìÂâçÊñπÂùó
            if (this.currentPiece) {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            this.drawBlock(
                                ctx,
                                this.currentPiece.x + x,
                                this.currentPiece.y + y,
                                this.colors[this.currentPiece.color]
                            );
                        }
                    }
                }
            }
        },
        
        drawBlock(ctx, x, y, color, blockSize = this.BLOCK_SIZE) {
            const pixelX = x * blockSize;
            const pixelY = y * blockSize;

            const gradient = ctx.createLinearGradient(pixelX, pixelY, pixelX + blockSize, pixelY + blockSize);
            gradient.addColorStop(0, this.lightenColor(color, 20));
            gradient.addColorStop(1, this.darkenColor(color, 20));

            ctx.fillStyle = gradient;
            ctx.fillRect(pixelX, pixelY, blockSize, blockSize);

            // Add a 3D-like highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.fillRect(pixelX + 2, pixelY + 2, blockSize - 4, 4);

            // Add a subtle border
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(pixelX, pixelY, blockSize, blockSize);
        },

        lightenColor(hex, percent) {
            hex = hex.replace(/^#/, '');
            const num = parseInt(hex, 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return `#${(0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1)}`;
        },

        darkenColor(hex, percent) {
            hex = hex.replace(/^#/, '');
            const num = parseInt(hex, 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return `#${(0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1)}`;
        },
        
        drawNext() {
            const canvas = this.$refs.nextCanvas;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            if (this.nextPiece) {
                const shape = this.pieces[this.nextPiece][0];
                const color = this.colors[this.pieceTypes.indexOf(this.nextPiece) + 1];
                const blockSize = 15;
                const offsetX = (canvas.width - shape[0].length * blockSize) / 2;
                const offsetY = (canvas.height - shape.length * blockSize) / 2;
                
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            ctx.fillStyle = color;
                            ctx.fillRect(
                                offsetX + x * blockSize,
                                offsetY + y * blockSize,
                                blockSize - 1,
                                blockSize - 1
                            );
                        }
                    }
                }
            }
        },
        
        gameLoop(time = 0) {
            if (this.gameOver) return;
            
            const deltaTime = time - this.lastTime;
            this.lastTime = time;
            
            if (!this.paused) {
                this.dropTime += deltaTime;
                if (this.dropTime > this.dropInterval) {
                    this.move(0, 1);
                    this.dropTime = 0;
                }
            }
            
            this.draw();
            requestAnimationFrame(this.gameLoop);
        },
        
        endGame() {
            this.gameOver = true;
            this.playSound('gameOver');
        },
        
        restart() {
            this.board = Array(this.BOARD_HEIGHT).fill().map(() => Array(this.BOARD_WIDTH).fill(0));
            this.score = 0;
            this.level = 1;
            this.lines = 0;
            this.combo = 0;
            this.maxCombo = 0;
            this.dropTime = 0;
            this.dropInterval = 1000;
            this.paused = false;
            this.gameOver = false;
            this.clearEffects = [];
            this.comboText = '';
            
            this.generatePiece();
            this.generateNextPiece();
            this.gameLoop();
        },
        
        togglePause() {
            if (!this.gameOver) {
                this.paused = !this.paused;
            }
        },
        
        // Ëß¶Êë∏‰∫ã‰ª∂Â§ÑÁêÜÔºàÁßªÂä®Á´Ø‰∏ìÁî®Ôºâ
        handleMoveTouch(dx, dy = 0) {
            if (this.gameOver || this.paused) return;
            
            // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫Âíå‰∫ã‰ª∂ÂÜíÊ≥°
            event.preventDefault();
            event.stopPropagation();
            
            this.actionType = { dx, dy };
            
            if (dy > 0) {
                // ÂçïÂáª‰∏ãÁßª
                this.move(0, 1);
                this.playSound('move');
            } else {
                // Â∑¶Âè≥ÁßªÂä®
                this.move(dx, 0);
                this.playSound('move');
            }
            
            // ÂêØÂä®ÈïøÊåâËÆ°Êó∂Âô®ÔºàÁßªÂä®Á´ØÁ®çÈïøÂª∂ËøüÔºâ
            this.longPressTimer = setTimeout(() => {
                this.startLongPress(dy > 0 ? { dx: 0, dy: 1, isDropping: true } : { dx, dy: 0 });
            }, 300);
        },
        
        handleRotateTouch() {
            if (this.gameOver || this.paused) return;
            
            // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫Âíå‰∫ã‰ª∂ÂÜíÊ≥°
            event.preventDefault();
            event.stopPropagation();
            
            this.actionType = 'rotate';
            this.rotate();
            this.playSound('rotate');
            
            // ÁßªÂä®Á´ØÊóãËΩ¨‰∏çÂêØÁî®ÈïøÊåâÔºàÈÅøÂÖçÈáçÂ§çÊóãËΩ¨ÈóÆÈ¢òÔºâ
        },
        
        handleTouchEndBtn() {
            // ÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫Âíå‰∫ã‰ª∂ÂÜíÊ≥°
            event.preventDefault();
            event.stopPropagation();
            
            this.stopAction();
        },
        
        // ÈïøÊåâÊéßÂà∂Ôºà‰∏ªË¶ÅÁî®‰∫éÊ°åÈù¢Á´ØÔºâ
        startMove(dx, dy = 0) {
            if (this.gameOver || this.paused) return;

            this.actionType = { dx, dy };

            if (dy > 0) {
                // ÂçïÂáª‰∏ãÁßª
                this.move(0, 1);
                this.playSound('move');
            } else {
                // Â∑¶Âè≥ÁßªÂä®
                this.move(dx, 0);
                this.playSound('move');
            }

            // ÂêØÂä®ÈïøÊåâËÆ°Êó∂Âô®
            this.longPressTimer = setTimeout(() => {
                this.startLongPress(dy > 0 ? { dx: 0, dy: 1, isDropping: true } : { dx, dy: 0 });
            }, 200);
        },
        
        startRotate() {
            if (this.gameOver || this.paused) return;
            
            this.actionType = 'rotate';
            this.rotate();
            this.playSound('rotate');
            
            // ÈïøÊåâÊ£ÄÊµã
            this.longPressTimer = setTimeout(() => {
                this.startLongPress();
            }, 200);
        },
        
        startLongPress(action) {
            // Ê∑ªÂä†ÈïøÊåâÊ†∑ÂºèÂà∞ÊâÄÊúâÊåâÈíÆÔºàÁÆÄÂåñÂ§ÑÁêÜÔºâ
            document.querySelectorAll('.control-btn').forEach(btn => {
                if (btn.matches(':active')) {
                    btn.classList.add('long-pressing');
                }
            });
            
            if (action && action.isDropping) {
                this.drop();
                this.playSound('drop');
                return;
            }
            
            this.actionInterval = setInterval(() => {
                if (this.actionType === 'rotate') {
                    this.rotate();
                    this.playSound('rotate');
                } else if (this.actionType && this.actionType.dx !== undefined) {
                    this.move(this.actionType.dx, this.actionType.dy || 0);
                    this.playSound('move');
                }
            }, 150); // Ë∞ÉÊï¥ÈáçÂ§çÈó¥ÈöîÔºåÈÅøÂÖçÁßªÂä®Á´ØÁßªÂä®‰∏§Ê†º
        },
        
        stopAction() {
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
            }
            
            if (this.actionInterval) {
                clearInterval(this.actionInterval);
                this.actionInterval = null;
            }
            
            // ÁßªÈô§ÈïøÊåâÊ†∑Âºè
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.classList.remove('long-pressing');
            });
            
            this.actionType = null;
        },
        
        // Èü≥ÊïàÁ≥ªÁªü
        initAudio() {
            try {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.createSounds();
            } catch (e) {
                console.log('Èü≥È¢ë‰∏çÊîØÊåÅ');
            }
        },
        
        createSounds() {
            // ÂàõÂª∫ÂêÑÁßçÈü≥Êïà
            this.sounds = {
                move: this.createTone(200, 0.1, 'square'),
                rotate: this.createTone(300, 0.1, 'triangle'),
                drop: this.createTone(150, 0.2, 'sawtooth'),
                place: this.createTone(100, 0.15, 'sine'),
                clear: this.createTone(400, 0.3, 'triangle'),
                tetris: this.createTone(600, 0.5, 'square'),
                combo: this.createTone(500, 0.2, 'sine'),
                gameOver: this.createTone(80, 1.0, 'sawtooth')
            };
        },
        
        createTone(frequency, duration, type = 'sine') {
            return () => {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            };
        },
        
        playSound(soundName) {
            if (this.sounds[soundName]) {
                this.sounds[soundName]();
            }
        },
        
        // ÈîÆÁõòÈïøÊåâÊéßÂà∂
        startKeyboardMove(dx, dy = 0) {
            if (this.gameOver || this.paused) return;
            
            // Á´ãÂç≥ÊâßË°å‰∏ÄÊ¨°ÁßªÂä®
            this.move(dx, dy);
            this.playSound('move');
            
            // ËÆæÁΩÆÈïøÊåâÊ£ÄÊµã
            this.longPressTimer = setTimeout(() => {
                this.actionType = { dx, dy };
                this.actionInterval = setInterval(() => {
                    if (this.actionType) {
                        this.move(this.actionType.dx, this.actionType.dy);
                        this.playSound('move');
                    }
                }, 80); // ÈîÆÁõòÈïøÊåâÊØîÊåâÈíÆÁ®çÂø´
            }, 150); // ÈîÆÁõòÈïøÊåâÂª∂ËøüÁ®çÁü≠
        },
        
        stopKeyboardAction() {
            if (this.longPressTimer) {
                clearTimeout(this.longPressTimer);
                this.longPressTimer = null;
            }
            
            if (this.actionInterval) {
                clearInterval(this.actionInterval);
                this.actionInterval = null;
            }
            
            this.actionType = null;
        },
        
        // Ëß¶Êë∏ÊéßÂà∂
        handleTouchStart(e) {
            e.preventDefault();
            this.touchStartX = e.touches[0].clientX;
            this.touchStartY = e.touches[0].clientY;
            this.touchStartTime = Date.now();
        },
        
        handleTouchMove(e) {
            e.preventDefault();
        },
        
        handleTouchEnd(e) {
            e.preventDefault();
            if (this.gameOver || this.paused) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            const dx = touchEndX - this.touchStartX;
            const dy = touchEndY - this.touchStartY;
            const touchDuration = Date.now() - this.touchStartTime;
            
            const minSwipeDistance = 30;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > minSwipeDistance) {
                    if (dx > 0) {
                        this.move(1, 0); // Âè≥Êªë
                        this.playSound('move');
                    } else {
                        this.move(-1, 0); // Â∑¶Êªë
                        this.playSound('move');
                    }
                }
            } else {
                if (Math.abs(dy) > minSwipeDistance) {
                    if (dy > 0) {
                        this.drop(); // ‰∏ãÊªë
                        this.playSound('drop');
                    }
                } else if (touchDuration < 200) {
                    this.rotate(); // Âø´ÈÄüÁÇπÂáª
                    this.playSound('rotate');
                }
            }
        },
        
        bindEvents() {
            document.addEventListener('keydown', (e) => {
                // ‰ΩøÁî® e.code ‰ª•ÂøΩÁï•Â§ßÂ∞èÂÜôÂíå‰øÆÈ•∞ÈîÆ
                const key = e.code;

                if (this.keyPressed[key]) return; // Â¶ÇÊûúÊåâÈîÆÂ∑≤Êåâ‰∏ãÔºåÂàô‰∏çÈáçÂ§çËß¶Âèë
                this.keyPressed[key] = true;

                // Êüê‰∫õÊåâÈîÆÂú®ÊöÇÂÅúÊàñÊ∏∏ÊàèÁªìÊùüÊó∂‰πüÂ∫îËØ•Â∑•‰Ωú
                if (key === 'KeyP') {
                    this.togglePause();
                    e.preventDefault();
                    return;
                }

                // ÂÖ∂‰ªñÊåâÈîÆÂè™Âú®Ê∏∏ÊàèËøõË°åÊó∂Â∑•‰Ωú
                if (this.gameOver || this.paused) return;

                switch(key) {
                    case 'ArrowLeft':
                        this.startKeyboardMove(-1, 0);
                        break;
                    case 'ArrowRight':
                        this.startKeyboardMove(1, 0);
                        break;
                    case 'ArrowDown':
                        this.startKeyboardMove(0, 1);
                        break;
                    case 'ArrowUp':
                    case 'Space': // Á©∫Ê†ºÈîÆÁöÑ e.code ÊòØ 'Space'
                        this.rotate();
                        this.playSound('rotate');
                        break;
                }
                e.preventDefault();
            });

            document.addEventListener('keyup', (e) => {
                const key = e.code;
                this.keyPressed[key] = false;

                if (['ArrowLeft', 'ArrowRight', 'ArrowDown'].includes(key)) {
                    this.stopKeyboardAction();
                }
            });
            
            // Èò≤Ê≠¢È°µÈù¢ÊªöÂä®ÂíåÁº©Êîæ
            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
            }, { passive: false });
            
            document.addEventListener('gesturestart', (e) => {
                e.preventDefault();
            });
            
            document.addEventListener('gesturechange', (e) => {
                e.preventDefault();
            });
            
            document.addEventListener('gestureend', (e) => {
                e.preventDefault();
            });
        }
    }
});

app.mount('#app');
    </script>
</body>
</html>